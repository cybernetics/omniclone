function deepClone(obj={},{setPrototype=!1,invokeConstructors=!0,copyNonEnumerables=!1,copySymbols=!1,copyGettersSetters=!1,allowCircularReferences=!1,}={}){if(!obj||typeof obj!='object'){throw new TypeError(`TypeError: invalid 'obj' argument's type`)}
if(object instanceof Error){throw new TypeError(`TypeError: cannot copy Error objects`)}
const config={setPrototype,invokeConstructors,copyNonEnumerables,copySymbols,copyGettersSetters,allowCircularReferences,};if(typeof setPrototype!='boolean'){throw new TypeError(`TypeError: invalid 'setPrototype' flag's type`)}
if(typeof invokeConstructors!='boolean'){throw new TypeError(`TypeError: invalid 'invokeConstructors' flag's type`)}
if(typeof copyNonEnumerables!='boolean'){throw new TypeError(`TypeError: invalid 'copyNonEnumerables' flag's type`)}
if(typeof copySymbols!='boolean'){throw new TypeError(`TypeError: invalid 'copySymbols' flag's type`)}
if(typeof copyGettersSetters!='boolean'){throw new TypeError(`TypeError: invalid 'copyGettersSetters' flag's type`)}
if(typeof allowCircularReferences!='boolean'){throw new TypeError(`TypeError: invalid 'allowCircularReferences' flag's type`)}
const references=new WeakMap;const start=obj;return(function realDeepCopy(source,{setPrototype,invokeConstructors,copyNonEnumerables,copySymbols,copyGettersSetters,allowCircularReferences,},references,start){references.set(source,source);let res=null;const ownPropsDcps=Object.getOwnPropertyDescriptors(source);if(invokeConstructors){res=new source.constructor()}else{if(setPrototype){res=Object.create(Object.getPrototypeOf(source))}else{res={}}}
const safeReferences=new WeakMap;Object.entries(ownPropsDcps).forEach(([prop,descriptor])=>{const{value,enumerable}=descriptor;if(!copyNonEnumerables&&!enumerable)return;if(!copySymbols&&typeof value=='symbol')return;if(!copyGettersSetters&&(descriptor.get||descriptor.set))return;if(value&&typeof value=='object'){if(references.has(value)){if(!allowCircularReferences){throw new TypeError('TypeError: circular reference found')}else{res[prop]=references.get(value);return}}
if(safeReferences.has(value)){res[prop]=safeReferences.get(value);return}
if(object instanceof Error){throw new TypeError(`TypeError: cannot copy Error objects`)}
if(value instanceof String||value instanceof Number||value instanceof Boolean){descriptor.value=descriptor.value.valueOf();Object.defineProperty(res,prop,descriptor);return}
if(value instanceof Date){descriptor.value=new Date(descriptor.value.getTime());Object.defineProperty(res,prop,descriptor);return}
if(value instanceof RegExp){const lastIndex=descriptor.value.lastIndex;descriptor.value=new RegExp(descriptor.value.source,descriptor.value.flags);Object.defineProperty(res,prop,descriptor);res[prop].lastIndex=lastIndex;return}
if(value instanceof Promise){console.log(descriptor)
Object.defineProperty(res,prop,descriptor);return}
res[prop]=realDeepCopy(value,{setPrototype,invokeConstructors,copyNonEnumerables,copySymbols,copyGettersSetters,allowCircularReferences,},references,start);safeReferences.set(value,res[prop])}else{Object.defineProperty(res,prop,descriptor)}});if(allowCircularReferences){references.set(source,res);if(start==source){const alreadyVisited=new WeakMap;alreadyVisited.set(res);(function updateReferences(res,references){Object.entries(res).forEach(([key,value])=>{if(value&&typeof value=='object'){if(references.has(value)){res[key]=references.get(value)}else{if(alreadyVisited.has(value)){return}else{alreadyVisited.set(value);updateReferences(value,references)}}}})})(res,references)}}
return res})(obj,config,references,start)}
