module.exports=function(e){var r={};function t(o){if(r[o])return r[o].exports;var n=r[o]={i:o,l:!1,exports:{}};return e[o].call(n.exports,n,n.exports,t),n.l=!0,n.exports}return t.m=e,t.c=r,t.d=function(e,r,o){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:o})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var n in e)t.d(o,n,function(r){return e[r]}.bind(null,n));return o},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=0)}([function(e,r,t){"use strict";function o(e={},{setPrototype:r=!1,invokeConstructors:t=!0,copyNonEnumerables:o=!1,copySymbols:n=!1,copyGettersSetters:i=!1,allowCircularReferences:c=!1}={}){if(!e||"object"!=typeof e)throw new TypeError("TypeError: invalid 'obj' argument's type");if(e instanceof Error)throw new TypeError("TypeError: cannot copy Error objects");const s={setPrototype:r,invokeConstructors:t,copyNonEnumerables:o,copySymbols:n,copyGettersSetters:i,allowCircularReferences:c};if("boolean"!=typeof r)throw new TypeError("TypeError: invalid 'setPrototype' flag's type");if("boolean"!=typeof t)throw new TypeError("TypeError: invalid 'invokeConstructors' flag's type");if("boolean"!=typeof o)throw new TypeError("TypeError: invalid 'copyNonEnumerables' flag's type");if("boolean"!=typeof n)throw new TypeError("TypeError: invalid 'copySymbols' flag's type");if("boolean"!=typeof i)throw new TypeError("TypeError: invalid 'copyGettersSetters' flag's type");if("boolean"!=typeof c)throw new TypeError("TypeError: invalid 'allowCircularReferences' flag's type");return function e(r,{setPrototype:t,invokeConstructors:o,copyNonEnumerables:n,copySymbols:i,copyGettersSetters:c,allowCircularReferences:s},a,f){a.set(r,r);let l=null;const p=Object.getOwnPropertyDescriptors(r);l=o?new r.constructor:t?Object.create(Object.getPrototypeOf(r)):{};const u=new WeakMap;if(Object.entries(p).forEach(([r,p])=>{const{value:y,enumerable:b}=p;if((n||b)&&(i||"symbol"!=typeof y)&&(c||!p.get&&!p.set))if(y&&"object"==typeof y){if(a.has(y)){if(s)return void(l[r]=a.get(y));throw new TypeError("TypeError: circular reference found")}if(u.has(y))return void(l[r]=u.get(y));if(y instanceof Error)throw new TypeError("TypeError: cannot copy Error objects");if(y instanceof String||y instanceof Number||y instanceof Boolean){const e=p.value.valueOf();return void Object.defineProperty(l,r,{...p,...{value:e}})}if(y instanceof Date){const e=new Date(p.value.getTime());return void Object.defineProperty(l,r,{...p,...{value:e}})}if(y instanceof RegExp){const{value:{lastIndex:e}}=p,t=new RegExp(p.value.source,p.value.flags);return Object.defineProperty(l,r,{...p,...{value:t}}),void(l[r].lastIndex=e)}if(y instanceof Promise)return void Object.defineProperty(l,r,p);l[r]=e(y,{setPrototype:t,invokeConstructors:o,copyNonEnumerables:n,copySymbols:i,copyGettersSetters:c,allowCircularReferences:s},a,f),u.set(y,l[r])}else Object.defineProperty(l,r,p)}),s&&(a.set(r,l),f===r)){const e=new WeakMap;e.set(l),function r(t,o){Object.entries(t).forEach(([n,i])=>{if(i&&"object"==typeof i)if(o.has(i))t[n]=o.get(i);else{if(e.has(i))return;e.set(i),r(i,o)}})}(l,a)}return l}(e,s,new WeakMap,e)}t.r(r),t.d(r,"omniclone",function(){return o})}]).default;